### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Accession {
  accessioned_on: Date!
  created_at: Date!
  data: JSONObject!
  id: String!
  index: Int!
  number: String!
  specimens: [Specimen!]
  taxon: Taxon!
  taxon_determinations: [TaxonDetermination!]
  year_index: Int!
}

input AccessionsBoolExp {
  AND: [AccessionsBoolExp]
  NOT: AccessionsBoolExp
  OR: [AccessionsBoolExp]
  id: StringComparisonInputType
  number: StringComparisonInputType
  specimens: SpecimensRelationBoolInput
}

input AccessionsRelationBoolInput {
  every: AccessionsBoolExp
  none: AccessionsBoolExp
  some: AccessionsBoolExp
}

type Account {
  id: String!
  name: String
  namespace: String
}

input AccountInputType {
  name: String!
  namespace: String
}

type AuthPayload {
  success: Boolean!
  token: String
  user: User
}

type Base {
  accession_number_format: String
  id: String!
  name: String
  namespace: String
  slug: String
  specimen_number_format: String
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

type HierarchicalLocation {
  id: String!
  name: String!
  parent_id: String
}

input IntComparisonInputType {
  equals: Int
  gt: Int
  lt: Int
  not: Int
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Location {
  id: String!
  locations_hierarchy: [HierarchicalLocation]
  name: String!
  parent_id: String
  specimens(includeSubLocations: Boolean): [Specimen!]
  specimens_count(includeSubLocations: Boolean): Int!
}

input LocationsBoolInput {
  AND: [LocationsBoolInput]
  NOT: LocationsBoolInput
  OR: [LocationsBoolInput]
  id: StringComparisonInputType
  name: StringComparisonInputType
  specimens: SpecimensRelationBoolInput
}

type MessagePayload {
  message: String!
  user: User
}

type Mutation {
  activateAccount(token: String!): MessagePayload
  createAccession(accessioned_on: Date, data: JSONObject, taxon_id: String!): Accession!
  login(cookie: Boolean!, email: String!, password: String!): AuthPayload!
  signup(account: AccountInputType!, email: String!, first_name: String!, last_name: String!, password: String!): MessagePayload
}

type Name {
  aggregate: String
  cultivar: String
  family: String
  flora_name_id: String
  form: String
  genus: String
  group: String
  id: String!
  infraspecific_epithet: String
  microspecies: String
  name_according_to: String
  name_authorship: String
  name_published_in: String
  name_published_in_year: Int
  scientific_name: String
  specific_epithet: String
  subform: String
  subgenus: String
  subspecies: String
  subvariety: String
  taxon_rank: TaxonRank
  taxon_remarks: String
  variety: String
}

type Query {
  accession(id: String, number: String): Accession
  accessions(where: AccessionsBoolExp): [Accession]
  base(id: String, slug: String): Base
  bases: [Base]
  currentUser: User
  location(id: String, name: String): Location
  locations(where: LocationsBoolInput): [Location]
  name(id: String): Name
  names: [Name]
  specimen(where: SpecimensBoolInput): Specimen
  specimens(where: SpecimensBoolInput): [Specimen]
  taxa: [Taxon]
  taxon(id: String): Taxon
  taxon_determination(id: String): TaxonDetermination
  taxon_determinations: [TaxonDetermination]
}

type Specimen {
  accession: Accession!
  id: String!
  location: Location!
  number: String!
  qualifier: String!
  quantity: Int
}

input SpecimensBoolInput {
  AND: [SpecimensBoolInput]
  NOT: SpecimensBoolInput
  OR: [SpecimensBoolInput]
  accession: AccessionsBoolExp
  id: StringComparisonInputType
  location: LocationsBoolInput
  qualifier: StringComparisonInputType
  quantity: IntComparisonInputType
}

input SpecimensRelationBoolInput {
  every: SpecimensBoolInput
  none: SpecimensBoolInput
  some: SpecimensBoolInput
}

input StringComparisonInputType {
  contains: String
  endsWith: String
  equals: String
  not: String
  startsWith: String
}

type Taxon {
  flora_taxon_id: String
  id: String!
  name: Name!
  synonyms: [Name!]
}

type TaxonDetermination {
  accession: Accession!
  determined_by: String!
  determined_on: Date!
  id: String!
  taxon: Taxon!
}

enum TaxonRank {
  cultivar
  form
  group
  microspecies
  species
  subform
  subspecies
  subvariety
  variety
}

type User {
  account: Account!
  email: String
  first_name: String
  id: String!
  last_name: String
}
